// Controllers/affiliateController.js
const Affiliate = require("../Models/AffiliateModel");
const AffiliateBooking = require("../Models/AffiliateBookingModel");
const Booking = require("../Models/BookingModel");
const User = require("../Models/UserModel");
const emailService = require("../Services/emailService");

const affiliateController = {
  // ========== AFFILIATE MANAGEMENT ==========
  
  // Create new affiliate
  createAffiliate: async (req, res) => {
    try {
      console.log('üìù Creating new affiliate');
      
      const {
        name,
        email,
        phone,
        commissionRate = 5,
        contactPerson,
        bankDetails,
        address,
        notes
      } = req.body;

      // Validate required fields
      if (!name || !email || !phone) {
        return res.status(400).json({
          success: false,
          message: "Name, email, and phone are required"
        });
      }

      // Check if affiliate already exists
      const existingAffiliate = await Affiliate.findOne({
        $or: [
          { email: email.toLowerCase() },
          { phone }
        ]
      });

      if (existingAffiliate) {
        return res.status(400).json({
          success: false,
          message: "Affiliate with this email or phone already exists"
        });
      }

      // Create affiliate (code will be auto-generated by pre-save hook)
      const affiliate = new Affiliate({
        name,
        email: email.toLowerCase(),
        phone,
        commissionRate: parseFloat(commissionRate) || 5,
        contactPerson,
        bankDetails,
        address,
        notes,
        createdBy: req.user.id
      });

      await affiliate.save();

      // Populate creator info
      const populatedAffiliate = await Affiliate.findById(affiliate._id)
        .populate('createdBy', 'firstName lastName email');

      // Send welcome email
      try {
        await emailService.sendAffiliateWelcomeEmail(populatedAffiliate);
      } catch (emailError) {
        console.error('Failed to send affiliate welcome email:', emailError);
      }

      console.log('‚úÖ Affiliate created:', {
        id: affiliate._id,
        name: affiliate.name,
        code: affiliate.affiliateCode
      });

      res.status(201).json({
        success: true,
        message: "Affiliate created successfully",
        affiliate: populatedAffiliate
      });

    } catch (error) {
      console.error('‚ùå Create affiliate error:', error);
      
      if (error.code === 11000) {
        return res.status(400).json({
          success: false,
          message: "Duplicate entry. Affiliate with this email or code already exists"
        });
      }

      res.status(500).json({
        success: false,
        message: "Failed to create affiliate",
        error: error.message
      });
    }
  },

  // Get all affiliates
  getAllAffiliates: async (req, res) => {
    try {
      const {
        page = 1,
        limit = 20,
        status,
        search,
        sortBy = 'createdAt',
        sortOrder = 'desc'
      } = req.query;

      const query = {};
      
      // Filter by status
      if (status && status !== 'all') {
        query.status = status;
      }

      // Search functionality
      if (search) {
        query.$or = [
          { name: { $regex: search, $options: 'i' } },
          { email: { $regex: search, $options: 'i' } },
          { affiliateCode: { $regex: search, $options: 'i' } },
          { phone: { $regex: search, $options: 'i' } }
        ];
      }

      // Build sort object
      const sort = {};
      sort[sortBy] = sortOrder === 'desc' ? -1 : 1;

      const affiliates = await Affiliate.find(query)
        .populate('createdBy', 'firstName lastName email')
        .sort(sort)
        .limit(parseInt(limit))
        .skip((parseInt(page) - 1) * parseInt(limit));

      const total = await Affiliate.countDocuments(query);

      // Get booking stats for each affiliate
      const affiliatesWithStats = await Promise.all(
        affiliates.map(async (affiliate) => {
          const bookingStats = await AffiliateBooking.aggregate([
            { $match: { affiliate: affiliate._id } },
            {
              $group: {
                _id: '$commissionStatus',
                count: { $sum: 1 },
                total: { $sum: '$commissionAmount' }
              }
            }
          ]);

          const stats = {
            pending: bookingStats.find(s => s._id === 'pending') || { count: 0, total: 0 },
            approved: bookingStats.find(s => s._id === 'approved') || { count: 0, total: 0 },
            paid: bookingStats.find(s => s._id === 'paid') || { count: 0, total: 0 }
          };

          return {
            ...affiliate.toObject(),
            bookingStats: stats
          };
        })
      );

      res.status(200).json({
        success: true,
        affiliates: affiliatesWithStats,
        pagination: {
          total,
          page: parseInt(page),
          limit: parseInt(limit),
          pages: Math.ceil(total / limit)
        }
      });

    } catch (error) {
      console.error('‚ùå Get affiliates error:', error);
      res.status(500).json({
        success: false,
        message: "Failed to fetch affiliates",
        error: error.message
      });
    }
  },

  // Get affiliate by ID
  getAffiliateById: async (req, res) => {
    try {
      const { id } = req.params;

      const affiliate = await Affiliate.findById(id)
        .populate('createdBy', 'firstName lastName email')
        .populate('updatedBy', 'firstName lastName email');

      if (!affiliate) {
        return res.status(404).json({
          success: false,
          message: "Affiliate not found"
        });
      }

      // Get detailed booking statistics
      const bookings = await AffiliateBooking.find({ affiliate: id })
        .populate({
          path: 'booking',
          populate: {
            path: 'property',
            select: 'title location'
          }
        })
        .sort({ appliedAt: -1 })
        .limit(50);

      const stats = await AffiliateBooking.aggregate([
        { $match: { affiliate: affiliate._id } },
        {
          $group: {
            _id: null,
            totalBookings: { $sum: 1 },
            totalEarnings: { $sum: '$bookingAmount' },
            totalCommission: { $sum: '$commissionAmount' },
            pendingCommission: {
              $sum: {
                $cond: [{ $eq: ['$commissionStatus', 'pending'] }, '$commissionAmount', 0]
              }
            },
            approvedCommission: {
              $sum: {
                $cond: [{ $eq: ['$commissionStatus', 'approved'] }, '$commissionAmount', 0]
              }
            },
            paidCommission: {
              $sum: {
                $cond: [{ $eq: ['$commissionStatus', 'paid'] }, '$commissionAmount', 0]
              }
            }
          }
        }
      ]);

      res.status(200).json({
        success: true,
        affiliate,
        bookings,
        stats: stats[0] || {
          totalBookings: 0,
          totalEarnings: 0,
          totalCommission: 0,
          pendingCommission: 0,
          approvedCommission: 0,
          paidCommission: 0
        }
      });

    } catch (error) {
      console.error('‚ùå Get affiliate error:', error);
      res.status(500).json({
        success: false,
        message: "Failed to fetch affiliate",
        error: error.message
      });
    }
  },

  // Update affiliate
  updateAffiliate: async (req, res) => {
    try {
      const { id } = req.params;
      const updateData = req.body;

      const affiliate = await Affiliate.findById(id);
      if (!affiliate) {
        return res.status(404).json({
          success: false,
          message: "Affiliate not found"
        });
      }

      // Check email uniqueness if being updated
      if (updateData.email && updateData.email !== affiliate.email) {
        const existingAffiliate = await Affiliate.findOne({ 
          email: updateData.email.toLowerCase() 
        });
        if (existingAffiliate) {
          return res.status(400).json({
            success: false,
            message: "Email already in use by another affiliate"
          });
        }
      }

      // Add updatedBy
      updateData.updatedBy = req.user.id;

      // If name is updated, regenerate initials and code
      if (updateData.name && updateData.name !== affiliate.name) {
        const nameParts = updateData.name.split(' ');
        if (nameParts.length >= 2) {
          updateData.initials = (nameParts[0][0] + nameParts[1][0]).toUpperCase();
        } else {
          updateData.initials = nameParts[0].substring(0, 2).toUpperCase();
        }
        
        // Generate new code with same pattern
        const count = await Affiliate.countDocuments({ 
          initials: updateData.initials 
        });
        const sequentialNumber = (count + 1).toString().padStart(3, '0');
        updateData.affiliateCode = `${updateData.initials}-${sequentialNumber}`;
      }

      const updatedAffiliate = await Affiliate.findByIdAndUpdate(
        id,
        updateData,
        { new: true, runValidators: true }
      ).populate('createdBy updatedBy', 'firstName lastName email');

      res.status(200).json({
        success: true,
        message: "Affiliate updated successfully",
        affiliate: updatedAffiliate
      });

    } catch (error) {
      console.error('‚ùå Update affiliate error:', error);
      res.status(500).json({
        success: false,
        message: "Failed to update affiliate",
        error: error.message
      });
    }
  },

  // Update affiliate status
  updateAffiliateStatus: async (req, res) => {
    try {
      const { id } = req.params;
      const { status } = req.body;

      const affiliate = await Affiliate.findById(id);
      if (!affiliate) {
        return res.status(404).json({
          success: false,
          message: "Affiliate not found"
        });
      }

      affiliate.status = status;
      affiliate.updatedBy = req.user.id;
      await affiliate.save();

      // Send status update email
      try {
        await emailService.sendAffiliateStatusUpdate(affiliate);
      } catch (emailError) {
        console.error('Failed to send status update email:', emailError);
      }

      res.status(200).json({
        success: true,
        message: `Affiliate status updated to ${status}`,
        affiliate
      });

    } catch (error) {
      console.error('‚ùå Update affiliate status error:', error);
      res.status(500).json({
        success: false,
        message: "Failed to update affiliate status",
        error: error.message
      });
    }
  },

  // Delete affiliate
  deleteAffiliate: async (req, res) => {
    try {
      const { id } = req.params;

      const affiliate = await Affiliate.findById(id);
      if (!affiliate) {
        return res.status(404).json({
          success: false,
          message: "Affiliate not found"
        });
      }

      // Check if affiliate has any bookings
      const hasBookings = await AffiliateBooking.exists({ affiliate: id });
      if (hasBookings) {
        return res.status(400).json({
          success: false,
          message: "Cannot delete affiliate with existing bookings. Deactivate instead."
        });
      }

      await Affiliate.findByIdAndDelete(id);

      res.status(200).json({
        success: true,
        message: "Affiliate deleted successfully"
      });

    } catch (error) {
      console.error('‚ùå Delete affiliate error:', error);
      res.status(500).json({
        success: false,
        message: "Failed to delete affiliate",
        error: error.message
      });
    }
  },

  // ========== AFFILIATE CODE VALIDATION ==========
  
  // Validate affiliate code
  validateAffiliateCode: async (req, res) => {
    try {
      const { code } = req.params;

      if (!code) {
        return res.status(400).json({
          success: false,
          message: "Affiliate code is required"
        });
      }

      const affiliate = await Affiliate.findOne({
        affiliateCode: code.toUpperCase(),
        status: 'active'
      }).select('name affiliateCode commissionRate stats');

      if (!affiliate) {
        return res.status(404).json({
          success: false,
          message: "Invalid or inactive affiliate code"
        });
      }

      res.status(200).json({
        success: true,
        message: "Valid affiliate code",
        affiliate: {
          id: affiliate._id,
          name: affiliate.name,
          code: affiliate.affiliateCode,
          commissionRate: affiliate.commissionRate
        }
      });

    } catch (error) {
      console.error('‚ùå Validate affiliate code error:', error);
      res.status(500).json({
        success: false,
        message: "Failed to validate affiliate code",
        error: error.message
      });
    }
  },

  // ========== AFFILIATE BOOKING MANAGEMENT ==========
  
  // Apply affiliate code to booking
  applyAffiliateCode: async (req, res) => {
    try {
      const { bookingId } = req.params;
      const { affiliateCode } = req.body;

      console.log('üìù Applying affiliate code:', { bookingId, affiliateCode });

      // Validate booking exists and belongs to user
      const booking = await Booking.findById(bookingId)
        .populate('property', 'title price');

      if (!booking) {
        return res.status(404).json({
          success: false,
          message: "Booking not found"
        });
      }

      // Check if user owns the booking
      if (booking.user.toString() !== req.user.id && req.user.role !== 'admin') {
        return res.status(403).json({
          success: false,
          message: "Access denied"
        });
      }

      // Check if booking already has an affiliate code
      const existingAffiliateBooking = await AffiliateBooking.findOne({ 
        booking: bookingId 
      });

      if (existingAffiliateBooking) {
        return res.status(400).json({
          success: false,
          message: "Affiliate code already applied to this booking"
        });
      }

      // Validate affiliate code
      const affiliate = await Affiliate.findOne({
        affiliateCode: affiliateCode.toUpperCase(),
        status: 'active'
      });

      if (!affiliate) {
        return res.status(404).json({
          success: false,
          message: "Invalid affiliate code"
        });
      }

      // Calculate commission
      const totalAmount = booking.priceBreakdown?.totalAmount || booking.totalAmount || 0;
      const commissionAmount = (totalAmount * affiliate.commissionRate) / 100;

      // Calculate nights
      const nights = Math.ceil(
        (new Date(booking.checkOut) - new Date(booking.checkIn)) / (1000 * 60 * 60 * 24)
      );

      // Create affiliate booking record
      const affiliateBooking = new AffiliateBooking({
        affiliate: affiliate._id,
        booking: bookingId,
        affiliateCode: affiliate.affiliateCode,
        bookingDetails: {
          propertyTitle: booking.property?.title || 'Unknown',
          propertyPrice: booking.property?.price || 0,
          checkIn: booking.checkIn,
          checkOut: booking.checkOut,
          nights,
          guests: booking.guests
        },
        bookingAmount: totalAmount,
        commissionRate: affiliate.commissionRate,
        commissionAmount,
        appliedBy: req.user.id,
        metadata: {
          userEmail: req.user.email,
          userPhone: req.user.phone
        }
      });

      await affiliateBooking.save();

      // Update affiliate stats
      affiliate.stats.totalBookings += 1;
      affiliate.stats.totalEarnings += totalAmount;
      affiliate.stats.totalCommission += commissionAmount;
      affiliate.stats.pendingCommission += commissionAmount;
      affiliate.lastBookingAt = new Date();
      await affiliate.save();

      console.log('‚úÖ Affiliate code applied successfully:', {
        affiliateCode: affiliate.affiliateCode,
        bookingId,
        commissionAmount
      });

      res.status(200).json({
        success: true,
        message: "Affiliate code applied successfully",
        affiliateBooking: {
          id: affiliateBooking._id,
          affiliate: {
            name: affiliate.name,
            code: affiliate.affiliateCode
          },
          bookingAmount: totalAmount,
          commissionRate: affiliate.commissionRate,
          commissionAmount
        }
      });

    } catch (error) {
      console.error('‚ùå Apply affiliate code error:', error);
      res.status(500).json({
        success: false,
        message: "Failed to apply affiliate code",
        error: error.message
      });
    }
  },

  // Get bookings for an affiliate
  getAffiliateBookings: async (req, res) => {
    try {
      const { affiliateId } = req.params;
      const {
        page = 1,
        limit = 20,
        status,
        startDate,
        endDate
      } = req.query;

      const query = { affiliate: affiliateId };

      if (status && status !== 'all') {
        query.commissionStatus = status;
      }

      if (startDate || endDate) {
        query.appliedAt = {};
        if (startDate) query.appliedAt.$gte = new Date(startDate);
        if (endDate) query.appliedAt.$lte = new Date(endDate);
      }

      const bookings = await AffiliateBooking.find(query)
        .populate({
          path: 'booking',
          populate: {
            path: 'property',
            select: 'title location images'
          }
        })
        .sort({ appliedAt: -1 })
        .limit(parseInt(limit))
        .skip((parseInt(page) - 1) * parseInt(limit));

      const total = await AffiliateBooking.countDocuments(query);

      // Calculate totals
      const totals = await AffiliateBooking.aggregate([
        { $match: query },
        {
          $group: {
            _id: null,
            totalBookings: { $sum: 1 },
            totalEarnings: { $sum: '$bookingAmount' },
            totalCommission: { $sum: '$commissionAmount' }
          }
        }
      ]);

      res.status(200).json({
        success: true,
        bookings,
        pagination: {
          total,
          page: parseInt(page),
          limit: parseInt(limit),
          pages: Math.ceil(total / limit)
        },
        totals: totals[0] || {
          totalBookings: 0,
          totalEarnings: 0,
          totalCommission: 0
        }
      });

    } catch (error) {
      console.error('‚ùå Get affiliate bookings error:', error);
      res.status(500).json({
        success: false,
        message: "Failed to fetch affiliate bookings",
        error: error.message
      });
    }
  },

  // ========== COMMISSION MANAGEMENT ==========
  
  // Update commission status
  updateCommissionStatus: async (req, res) => {
    try {
      const { id } = req.params;
      const { status, notes } = req.body;

      const affiliateBooking = await AffiliateBooking.findById(id)
        .populate('affiliate');

      if (!affiliateBooking) {
        return res.status(404).json({
          success: false,
          message: "Affiliate booking record not found"
        });
      }

      const previousStatus = affiliateBooking.commissionStatus;

      // Update based on status
      switch (status) {
        case 'approved':
          await affiliateBooking.approve(req.user.id);
          break;
        case 'paid':
          affiliateBooking.commissionStatus = 'paid';
          affiliateBooking.paidAt = new Date();
          affiliateBooking.paidBy = req.user.id;
          affiliateBooking.notes = notes || affiliateBooking.notes;
          await affiliateBooking.save();
          break;
        case 'cancelled':
          affiliateBooking.commissionStatus = 'cancelled';
          affiliateBooking.notes = notes || 'Commission cancelled';
          await affiliateBooking.save();
          
          // Update affiliate stats
          const affiliate = await Affiliate.findById(affiliateBooking.affiliate);
          if (affiliate) {
            affiliate.stats.totalCommission -= affiliateBooking.commissionAmount;
            affiliate.stats.pendingCommission -= affiliateBooking.commissionAmount;
            await affiliate.save();
          }
          break;
        default:
          affiliateBooking.commissionStatus = status;
          affiliateBooking.notes = notes;
          await affiliateBooking.save();
      }

      console.log('‚úÖ Commission status updated:', {
        bookingId: affiliateBooking.booking,
        previousStatus,
        newStatus: status
      });

      res.status(200).json({
        success: true,
        message: `Commission status updated to ${status}`,
        affiliateBooking
      });

    } catch (error) {
      console.error('‚ùå Update commission status error:', error);
      res.status(500).json({
        success: false,
        message: "Failed to update commission status",
        error: error.message
      });
    }
  },

  // ========== AFFILIATE STATISTICS ==========
  
  // Get affiliate dashboard stats
  getAffiliateStats: async (req, res) => {
    try {
      const { id } = req.params;

      const affiliate = await Affiliate.findById(id);
      if (!affiliate) {
        return res.status(404).json({
          success: false,
          message: "Affiliate not found"
        });
      }

      // Get monthly stats for the last 12 months
      const twelveMonthsAgo = new Date();
      twelveMonthsAgo.setMonth(twelveMonthsAgo.getMonth() - 12);

      const monthlyStats = await AffiliateBooking.aggregate([
        {
          $match: {
            affiliate: affiliate._id,
            appliedAt: { $gte: twelveMonthsAgo }
          }
        },
        {
          $group: {
            _id: {
              year: { $year: '$appliedAt' },
              month: { $month: '$appliedAt' }
            },
            bookings: { $sum: 1 },
            earnings: { $sum: '$bookingAmount' },
            commission: { $sum: '$commissionAmount' }
          }
        },
        { $sort: { '_id.year': 1, '_id.month': 1 } }
      ]);

      // Get top performing months
      const topMonths = monthlyStats
        .sort((a, b) => b.commission - a.commission)
        .slice(0, 5);

      // Get conversion rate (if you have click tracking)
      // This would need a separate Click model

      res.status(200).json({
        success: true,
        stats: affiliate.stats,
        monthlyStats,
        topMonths,
        performance: {
          averageCommissionPerBooking: affiliate.stats.totalBookings > 0 
            ? affiliate.stats.totalCommission / affiliate.stats.totalBookings 
            : 0,
          averageBookingValue: affiliate.stats.totalBookings > 0
            ? affiliate.stats.totalEarnings / affiliate.stats.totalBookings
            : 0,
          commissionRate: affiliate.commissionRate
        }
      });

    } catch (error) {
      console.error('‚ùå Get affiliate stats error:', error);
      res.status(500).json({
        success: false,
        message: "Failed to fetch affiliate statistics",
        error: error.message
      });
    }
  },

  // Get all affiliates summary stats (for admin dashboard)
  getAffiliatesSummary: async (req, res) => {
    try {
      const stats = await Affiliate.aggregate([
        {
          $group: {
            _id: null,
            totalAffiliates: { $sum: 1 },
            activeAffiliates: {
              $sum: { $cond: [{ $eq: ['$status', 'active'] }, 1, 0] }
            },
            totalEarnings: { $sum: '$stats.totalEarnings' },
            totalCommission: { $sum: '$stats.totalCommission' },
            paidCommission: { $sum: '$stats.paidCommission' },
            pendingCommission: { $sum: '$stats.pendingCommission' },
            totalBookings: { $sum: '$stats.totalBookings' }
          }
        }
      ]);

      const topAffiliates = await Affiliate.find({ status: 'active' })
        .sort({ 'stats.totalCommission': -1 })
        .limit(10)
        .select('name affiliateCode stats commissionRate');

      res.status(200).json({
        success: true,
        summary: stats[0] || {
          totalAffiliates: 0,
          activeAffiliates: 0,
          totalEarnings: 0,
          totalCommission: 0,
          paidCommission: 0,
          pendingCommission: 0,
          totalBookings: 0
        },
        topAffiliates
      });

    } catch (error) {
      console.error('‚ùå Get affiliates summary error:', error);
      res.status(500).json({
        success: false,
        message: "Failed to fetch affiliates summary",
        error: error.message
      });
    }
  }
};

module.exports = affiliateController;